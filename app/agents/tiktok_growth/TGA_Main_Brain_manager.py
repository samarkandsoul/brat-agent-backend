# app/agents/tiktok_growth/TGA_Main_Brain_manager.py

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import datetime

from .trend_brain import TrendBrain
from .video_lab import VideoLab, VideoRenderResult
from .tiktok_api_client import TikTokApiClient


@dataclass
class TGAVideoDraft:
    """Represents a single video idea or draft before posting."""
    id: str
    title: str
    caption: str
    status: str  # "draft" | "approved" | "rejected" | "posted"
    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)
    meta: Dict[str, Any] = field(default_factory=dict)


class TikTokGrowthAgent:
    """
    Core orchestrator for TikTok content workflow.

    High-level responsibilities:
      - Plan daily videos (via TrendBrain)
      - Ask VideoLab to prepare previews
      - Build Telegram payloads for human approval
      - (Later) Post approved videos to TikTok
      - (Later) Read comments & analytics
      - (Later) Propose improvements for the next day
    """

    def __init__(self) -> None:
        self.video_queue: List[TGAVideoDraft] = []
        self.trend_brain = TrendBrain()
        self.video_lab = VideoLab()
        self.tiktok_client = TikTokApiClient()  # not used yet, just ready

    # ===== PUBLIC ENTRYPOINTS =====

    def run_daily_cycle(self) -> None:
        """
        High-level daily workflow.
        Later this will be triggered by a cron job.
        For now it's just a placeholder that we can call manually.
        """
        print("[TGA] Starting daily cycle...")
        self.plan_videos_for_today()
        self.prepare_video_drafts()
        self.send_previews_for_approval()
        print("[TGA] Daily cycle finished (waiting for approvals).")

    def handle_telegram_approval(self, draft_id: str, approved: bool) -> None:
        """
        Called when the user approves or rejects a draft via Telegram.
        For now it only updates the status and logs to console.
        """
        draft = self._find_draft(draft_id)
        if not draft:
            print(f"[TGA] Draft not found: {draft_id}")
            return

        if approved:
            draft.status = "approved"
            print(f"[TGA] Draft approved: {draft.id}")
            # TODO: later -> call TikTok API to post it
        else:
            draft.status = "rejected"
            print(f"[TGA] Draft rejected: {draft.id}")
            # TODO: later -> trigger regeneration here

    # ===== INTERNAL STEPS =====

    def plan_videos_for_today(self, num_videos: int = 3) -> None:
        """
        Ask TrendBrain for a high-level plan for today and
        create TGAVideoDraft objects accordingly.
        """
        print(f"[TGA] Planning {num_videos} videos for today via TrendBrain...")
        self.video_queue = []  # reset queue

        plans = self.trend_brain.suggest_daily_plan(num_videos=num_videos)

        for plan in plans:
            draft = TGAVideoDraft(
                id=plan["plan_id"],
                title=plan["title_hint"],
                caption="Caption will be generated by LLM later.",
                status="draft",
                meta={"plan": plan},
            )
            self.video_queue.append(draft)

        print(f"[TGA] Planned {len(self.video_queue)} drafts.")

    def prepare_video_drafts(self) -> None:
        """
        Ask VideoLab to build previews for each draft.
        For now this just calls the stub renderer.
        """
        print("[TGA] Preparing video drafts via VideoLab (stub)...")

        for draft in self.video_queue:
            plan = draft.meta.get("plan", {})
            render_result: VideoRenderResult = self.video_lab.render_stub_preview(plan)
            draft.meta["render"] = render_result.to_dict()

        print("[TGA] All drafts now have stub preview metadata.")

    def send_previews_for_approval(self) -> None:
        """
        Build Telegram-friendly payloads and (for now) just log them.
        Later, MSP / bot layer will call build_telegram_preview_payloads()
        and actually send these via Telegram Bot API.
        """
        print("[TGA] Preparing previews for Telegram approval (console stub)...")

        payloads = self.build_telegram_preview_payloads()

        for payload in payloads:
            print("[TGA] TELEGRAM PREVIEW PAYLOAD:", payload)

        print("[TGA] All previews 'prepared' for Telegram (stub).")

    # ===== TELEGRAM PAYLOAD BUILDERS =====

    def build_telegram_preview_payloads(self) -> List[Dict[str, Any]]:
        """
        Return a list of dicts that Telegram bot can use directly.

        Each payload has shape:
          {
            "text": "...",
            "reply_markup": {
                "inline_keyboard": [
                    [
                        {"text": "‚úÖ Approve", "callback_data": "tga_approve:<draft_id>"},
                        {"text": "‚ùå Reject",  "callback_data": "tga_reject:<draft_id>"}
                    ]
                ]
            }
          }

        MSP / bot layer is responsible for:
          - looping over this list
          - calling sendMessage(chat_id, **payload)
          - routing callback_data back to handle_telegram_approval()
        """
        payloads: List[Dict[str, Any]] = []

        for draft in self.video_queue:
            render_meta = draft.meta.get("render", {})
            preview_note = render_meta.get("preview_note", "")

            text_lines = [
                "üìπ *TikTok Draft Preview*",
                "",
                f"*ID:* `{draft.id}`",
                f"*Title:* {draft.title}",
                "",
                f"*Preview:* {preview_note}",
                "",
                "_Approve to schedule this video for posting._",
            ]
            text = "\n".join(text_lines)

            payload = {
                "text": text,
                "parse_mode": "Markdown",
                "reply_markup": {
                    "inline_keyboard": [
                        [
                            {
                                "text": "‚úÖ Approve",
                                "callback_data": f"tga_approve:{draft.id}",
                            },
                            {
                                "text": "‚ùå Reject",
                                "callback_data": f"tga_reject:{draft.id}",
                            },
                        ]
                    ]
                },
            }

            payloads.append(payload)

        return payloads

    # ===== HELPER METHODS =====

    def _find_draft(self, draft_id: str) -> Optional[TGAVideoDraft]:
        for d in self.video_queue:
            if d.id == draft_id:
                return d
        return None
